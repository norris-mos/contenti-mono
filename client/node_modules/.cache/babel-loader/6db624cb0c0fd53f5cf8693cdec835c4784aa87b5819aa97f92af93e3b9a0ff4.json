{"ast":null,"code":"export class ContentService {\n  /**\n   *\n   */\n\n  // THIS IS NORMALLU EMPTY\n  constructor() {\n    let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http://localhost:8080/';\n    this.baseUrl = baseUrl;\n    this.csrfToken = undefined;\n    this.delete = async contentId => {\n      var _this$csrfToken;\n      console.log(`ContentService: deleting ${contentId}...`);\n      const result = await fetch(`${this.baseUrl}/${contentId}`, {\n        method: 'delete',\n        headers: {\n          'CSRF-Token': (_this$csrfToken = this.csrfToken) !== null && _this$csrfToken !== void 0 ? _this$csrfToken : ''\n        }\n      });\n      if (!result.ok) {\n        throw new Error(`Error while deleting content: ${result.status} ${result.statusText} ${await result.text()}`);\n      }\n    };\n    this.getEdit = async contentId => {\n      console.log('is this evening updating');\n      console.log(`ContentService: Getting information to edit ${contentId}...`);\n      console.log(`${this.baseUrl}/${contentId}/edit`);\n      const res = await fetch(`${this.baseUrl}/${contentId}/edit`);\n      if (!res || !res.ok) {\n        throw new Error(`${res.status} ${res.statusText}`);\n      }\n      console.log(res.json);\n      return res.json();\n    };\n    this.getPlay = async contentId => {\n      console.log(`ContentService: Getting information to play ${contentId}...`);\n      console.log(`${this.baseUrl}/${contentId}/play`);\n      const res = await fetch(`${this.baseUrl}/${contentId}/play`);\n      if (!res || !res.ok) {\n        throw new Error(`${res.status} ${res.statusText}`);\n      }\n      return res.json();\n    };\n    this.list = async () => {\n      console.log(`ContentService: Listing content objects`);\n      const result = await fetch(this.baseUrl);\n      if (result.ok) {\n        return result.json();\n      }\n      throw new Error(`Request to REST endpoint returned ${result.status} ${result.statusText}: ${await result.text()}`);\n    };\n    // Just need to be careful about the base url not redirecting the /h5p/prompt\n    this.prompt = async (promptText, contentType) => {\n      console.log('Generating content...');\n      const url = `http://localhost:8080/prompt/${contentType}`;\n      const requestOptions = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          promptText,\n          contentType\n        })\n      };\n      try {\n        const response = await fetch(url, requestOptions);\n        if (!response.ok) {\n          console.log('fetch is not working');\n          throw new Error(`${response.status} ${response.statusText}`);\n        }\n        const responseJSON = await response.json();\n        //console.log('here is the response body object');\n        //console.log('content type', contentType);\n        //console.log('response from langchain', responseJSON);\n        //this.save(undefined);\n        //console.log('here is the responseJSON', responseJSON.model);\n\n        const promptSaveModel = responseJSON.model;\n        const promptSaveModel2 = responseJSON.model2;\n\n        // const promptSave: { contentId: string; metadata: IContentMetadata } = {\n        //   contentId: promptSaveModel.contentId,\n        //   metadata: promptSaveModel.metadata,\n        // };\n\n        // const promptSave2: { contentId: string; metadata: IContentMetadata } = {\n        //   contentId: promptSaveModel2.contentId,\n        //   metadata: promptSaveModel2.metadata,\n        // };\n        console.log('this apprars to be eerror');\n        const saveMethod = await this.save('', promptSaveModel);\n        console.log('save 1 works');\n        const saveMethod2 = await this.save('', promptSaveModel2);\n        console.log('save two doesnt');\n        const responses = {\n          p1: Promise.resolve(saveMethod),\n          p2: Promise.resolve(saveMethod2)\n        };\n        //const promptEdit = this.getEdit(promptSave.contentId);\n\n        return responses;\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n    };\n    this.save = async (contentId, requestBody) => {\n      var _this$csrfToken2, _this$csrfToken3, _this$csrfToken4;\n      if (contentId) {\n        console.log(`ContentService: Saving new content.`);\n      } else {\n        console.log(`the content id is ${contentId} i think`);\n        console.log(`ContentService: Savin content ${contentId}`);\n      }\n      const body = JSON.stringify(requestBody);\n      //console.log('this is the content id', contentId);\n      const requestbod = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'CSRF-Token': (_this$csrfToken2 = this.csrfToken) !== null && _this$csrfToken2 !== void 0 ? _this$csrfToken2 : ''\n        },\n        body: body\n      };\n      console.log(requestbod);\n      const res = contentId ? await fetch(`${this.baseUrl}/${contentId}`, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'CSRF-Token': (_this$csrfToken3 = this.csrfToken) !== null && _this$csrfToken3 !== void 0 ? _this$csrfToken3 : ''\n        },\n        body\n      }) : await fetch(this.baseUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'CSRF-Token': (_this$csrfToken4 = this.csrfToken) !== null && _this$csrfToken4 !== void 0 ? _this$csrfToken4 : ''\n        },\n        //credentials: 'include',\n        body\n      });\n      if (!res || !res.ok) {\n        throw new Error(`${res.status} ${res.statusText} - ${await res.text()}`);\n      }\n      return res.json();\n    };\n    this.generateDownloadLink = contentId => `${this.baseUrl}/download/${contentId}`;\n    this.setCsrfToken = csrfToken => {\n      this.csrfToken = csrfToken;\n    };\n    this.getCsrfToken = () => {\n      return this.csrfToken;\n    };\n  }\n}","map":{"version":3,"names":["ContentService","constructor","baseUrl","arguments","length","undefined","csrfToken","delete","contentId","_this$csrfToken","console","log","result","fetch","method","headers","ok","Error","status","statusText","text","getEdit","res","json","getPlay","list","prompt","promptText","contentType","url","requestOptions","body","JSON","stringify","response","responseJSON","promptSaveModel","model","promptSaveModel2","model2","saveMethod","save","saveMethod2","responses","p1","Promise","resolve","p2","error","requestBody","_this$csrfToken2","_this$csrfToken3","_this$csrfToken4","requestbod","generateDownloadLink","setCsrfToken","getCsrfToken"],"sources":["/Users/maxoliverstapyltonnorris/contenti-mono/client/src/services/ContentService.ts"],"sourcesContent":["import type {\n  IEditorModel,\n  IPlayerModel,\n  IContentMetadata,\n} from '@lumieducation/h5p-server';\nimport { json } from 'stream/consumers';\n\nexport interface IContentListEntry {\n  contentId: string;\n  mainLibrary: string;\n  title: string;\n  originalNewKey?: string;\n}\n\ninterface IPromptResponses {\n  p1: Promise<{ contentId: string; metadata: IContentMetadata }>;\n  p2: Promise<{ contentId: string; metadata: IContentMetadata }>;\n}\n\nexport interface IContentService {\n  delete(contentId: string): Promise<void>;\n  getEdit(contentId: string): Promise<IEditorModel>;\n  getPlay(contentId: string): Promise<IPlayerModel>;\n  list(): Promise<IContentListEntry[]>;\n  save(\n    contentId: string,\n    requestBody: { library: string; params: any }\n  ): Promise<{ contentId: string; metadata: IContentMetadata }>;\n  prompt(prompt: string, contenttype: string): Promise<IPromptResponses>;\n  generateDownloadLink(contentId: string): string;\n}\n\nexport class ContentService implements IContentService {\n  /**\n   *\n   */\n\n  // THIS IS NORMALLU EMPTY\n  constructor(protected baseUrl: string = 'http://localhost:8080/') {}\n\n  private csrfToken: string | undefined = undefined;\n\n  delete = async (contentId: string): Promise<void> => {\n    console.log(`ContentService: deleting ${contentId}...`);\n    const result = await fetch(`${this.baseUrl}/${contentId}`, {\n      method: 'delete',\n      headers: {\n        'CSRF-Token': this.csrfToken ?? '',\n      },\n    });\n    if (!result.ok) {\n      throw new Error(\n        `Error while deleting content: ${result.status} ${\n          result.statusText\n        } ${await result.text()}`\n      );\n    }\n  };\n\n  getEdit = async (contentId: string): Promise<IEditorModel> => {\n    console.log('is this evening updating');\n    console.log(`ContentService: Getting information to edit ${contentId}...`);\n\n    console.log(`${this.baseUrl}/${contentId}/edit`);\n    const res = await fetch(`${this.baseUrl}/${contentId}/edit`);\n\n    if (!res || !res.ok) {\n      throw new Error(`${res.status} ${res.statusText}`);\n    }\n    console.log(res.json);\n    return res.json();\n  };\n\n  getPlay = async (contentId: string): Promise<IPlayerModel> => {\n    console.log(`ContentService: Getting information to play ${contentId}...`);\n    console.log(`${this.baseUrl}/${contentId}/play`);\n    const res = await fetch(`${this.baseUrl}/${contentId}/play`);\n    if (!res || !res.ok) {\n      throw new Error(`${res.status} ${res.statusText}`);\n    }\n    return res.json();\n  };\n\n  list = async (): Promise<IContentListEntry[]> => {\n    console.log(`ContentService: Listing content objects`);\n    const result = await fetch(this.baseUrl);\n    if (result.ok) {\n      return result.json();\n    }\n    throw new Error(\n      `Request to REST endpoint returned ${result.status} ${\n        result.statusText\n      }: ${await result.text()}`\n    );\n  };\n\n  // Just need to be careful about the base url not redirecting the /h5p/prompt\n\n  prompt = async (\n    promptText: string,\n    contentType: string\n  ): Promise<IPromptResponses> => {\n    console.log('Generating content...');\n\n    const url = `http://localhost:8080/prompt/${contentType}`;\n\n    const requestOptions: RequestInit = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ promptText, contentType }),\n    };\n\n    try {\n      const response = await fetch(url, requestOptions);\n\n      if (!response.ok) {\n        console.log('fetch is not working');\n        throw new Error(`${response.status} ${response.statusText}`);\n      }\n      const responseJSON = await response.json();\n      //console.log('here is the response body object');\n      //console.log('content type', contentType);\n      //console.log('response from langchain', responseJSON);\n      //this.save(undefined);\n      //console.log('here is the responseJSON', responseJSON.model);\n\n      const promptSaveModel = responseJSON.model;\n      const promptSaveModel2 = responseJSON.model2;\n\n      // const promptSave: { contentId: string; metadata: IContentMetadata } = {\n      //   contentId: promptSaveModel.contentId,\n      //   metadata: promptSaveModel.metadata,\n      // };\n\n      // const promptSave2: { contentId: string; metadata: IContentMetadata } = {\n      //   contentId: promptSaveModel2.contentId,\n      //   metadata: promptSaveModel2.metadata,\n      // };\n      console.log('this apprars to be eerror');\n      const saveMethod = await this.save('', promptSaveModel);\n      console.log('save 1 works');\n      const saveMethod2 = await this.save('', promptSaveModel2);\n      console.log('save two doesnt');\n      const responses: IPromptResponses = {\n        p1: Promise.resolve(saveMethod),\n        p2: Promise.resolve(saveMethod2),\n      };\n      //const promptEdit = this.getEdit(promptSave.contentId);\n\n      return responses;\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  };\n\n  save = async (\n    contentId: string,\n    requestBody: { library: string; params: any }\n  ): Promise<{ contentId: string; metadata: IContentMetadata }> => {\n    if (contentId) {\n      console.log(`ContentService: Saving new content.`);\n    } else {\n      console.log(`the content id is ${contentId} i think`);\n      console.log(`ContentService: Savin content ${contentId}`);\n    }\n\n    const body = JSON.stringify(requestBody);\n    //console.log('this is the content id', contentId);\n    const requestbod = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'CSRF-Token': this.csrfToken ?? '',\n      },\n      body: body,\n    };\n    console.log(requestbod);\n\n    const res = contentId\n      ? await fetch(`${this.baseUrl}/${contentId}`, {\n          method: 'PATCH',\n          headers: {\n            'Content-Type': 'application/json',\n            'CSRF-Token': this.csrfToken ?? '',\n          },\n          body,\n        })\n      : await fetch(this.baseUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'CSRF-Token': this.csrfToken ?? '',\n          },\n          //credentials: 'include',\n          body,\n        });\n\n    if (!res || !res.ok) {\n      throw new Error(`${res.status} ${res.statusText} - ${await res.text()}`);\n    }\n    return res.json();\n  };\n  generateDownloadLink = (contentId: string): string =>\n    `${this.baseUrl}/download/${contentId}`;\n\n  setCsrfToken = (csrfToken: string | undefined): void => {\n    this.csrfToken = csrfToken;\n  };\n  getCsrfToken = (): string | undefined => {\n    return this.csrfToken;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}