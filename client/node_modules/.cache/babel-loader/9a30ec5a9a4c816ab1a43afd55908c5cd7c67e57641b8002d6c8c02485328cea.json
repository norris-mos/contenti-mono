{"ast":null,"code":"import AwaitLock from 'await-lock';\nconst lock = new AwaitLock();\n/**\n * Adds JavaScript file references to the DOM of the target element. If the\n * script was already added to the target element, it is not added a second\n * time. Makes sure the scripts are loaded in the order of the list.\n * @param scripts a list URLS to JavaScript files\n * @param target the element to which the scripts should be added.\n * @returns ignore the return value\n */\nexport async function addScripts(scripts, target) {\n  // We need to lock this function to avoid it being started nearly\n  // simultaneously. This can happen if several instances of the web component\n  // are added to the DOM at the same time. This can lead to situations in\n  // which the second run finds scripts that were already added to the DOM,\n  // but aren't parsed by the browser. The addScripts promise the resolves at\n  // a time when not all scripts have been fully loaded. This means that the\n  // global H5P objects and functions are not available yet, even though they\n  // should be.\n  await lock.acquireAsync();\n  try {\n    const existingScripts = Array.from(target.getElementsByTagName('script')).map(el => el.dataset.h5pSrc);\n    await Promise.all(scripts.map(scriptUrl => {\n      // Only add scripts once\n      if (existingScripts.some(existingSrc => existingSrc === scriptUrl)) {\n        return Promise.resolve();\n      }\n      const scriptTag = document.createElement('script');\n      scriptTag.src = scriptUrl;\n      // We store the original src used by H5P as the protocol and\n      // hostname are part of the src attribute.\n      scriptTag.dataset.h5pSrc = scriptUrl;\n      scriptTag.async = false;\n      scriptTag.defer = true;\n      const promise = new Promise((res, rej) => {\n        scriptTag.onload = () => {\n          res();\n        };\n        scriptTag.onerror = rej;\n      });\n      target.appendChild(scriptTag);\n      return promise;\n    }));\n  } finally {\n    lock.release();\n  }\n}\n/**\n * Adds links to CSS files to the DOM of the target element. If a stylesheet was\n * already added to the target element, it is not added a second time.\n * @param styles a list of URLs to stylesheets to add\n * @param target the element to which the scripts should be added\n * @param addFontsToHead if true, @font-face rules found in the loaded\n * stylesheets will also be duplicated and added to the head of the document.\n * This is necessary to load fonts that should be displayed inside the shadow\n * DOM.\n */\nexport function addStylesheets(styles, target) {\n  const existingTargetStylesheets = Array.from(target.getElementsByTagName('link')).map(el => el.dataset.h5pHref);\n  for (const styleUrl of styles) {\n    // Only add stylesheets once\n    if (existingTargetStylesheets.some(h5pHref => h5pHref === styleUrl)) {\n      continue;\n    }\n    const stylesheet = document.createElement('link');\n    // We store the original href in the data-h5p-attribute as the browser\n    // internally adds the protocol and hostname to the href attribute.\n    stylesheet.dataset.h5pHref = styleUrl;\n    stylesheet.rel = 'stylesheet';\n    stylesheet.href = styleUrl;\n    stylesheet.type = 'text/css';\n    target.appendChild(stylesheet);\n  }\n}","map":{"version":3,"names":["AwaitLock","lock","addScripts","scripts","target","acquireAsync","existingScripts","Array","from","getElementsByTagName","map","el","dataset","h5pSrc","Promise","all","scriptUrl","some","existingSrc","resolve","scriptTag","document","createElement","src","async","defer","promise","res","rej","onload","onerror","appendChild","release","addStylesheets","styles","existingTargetStylesheets","h5pHref","styleUrl","stylesheet","rel","href","type"],"sources":["/Users/maxoliverstapyltonnorris/contenti-mono/h5p-rest-example-client/node_modules/@lumieducation/h5p-webcomponents/src/dom-utils.ts"],"sourcesContent":["import AwaitLock from 'await-lock';\n\nconst lock = new AwaitLock();\n\n/**\n * Adds JavaScript file references to the DOM of the target element. If the\n * script was already added to the target element, it is not added a second\n * time. Makes sure the scripts are loaded in the order of the list.\n * @param scripts a list URLS to JavaScript files\n * @param target the element to which the scripts should be added.\n * @returns ignore the return value\n */\nexport async function addScripts(\n    scripts: string[],\n    target: HTMLElement\n): Promise<any> {\n    // We need to lock this function to avoid it being started nearly\n    // simultaneously. This can happen if several instances of the web component\n    // are added to the DOM at the same time. This can lead to situations in\n    // which the second run finds scripts that were already added to the DOM,\n    // but aren't parsed by the browser. The addScripts promise the resolves at\n    // a time when not all scripts have been fully loaded. This means that the\n    // global H5P objects and functions are not available yet, even though they\n    // should be.\n    await lock.acquireAsync();\n    try {\n        const existingScripts = Array.from(\n            target.getElementsByTagName('script')\n        ).map((el) => el.dataset.h5pSrc);\n        await Promise.all(\n            scripts.map((scriptUrl) => {\n                // Only add scripts once\n                if (\n                    existingScripts.some(\n                        (existingSrc) => existingSrc === scriptUrl\n                    )\n                ) {\n                    return Promise.resolve();\n                }\n                const scriptTag = document.createElement('script');\n                scriptTag.src = scriptUrl;\n                // We store the original src used by H5P as the protocol and\n                // hostname are part of the src attribute.\n                scriptTag.dataset.h5pSrc = scriptUrl;\n                scriptTag.async = false;\n                scriptTag.defer = true;\n                const promise = new Promise<void>((res, rej) => {\n                    scriptTag.onload = (): void => {\n                        res();\n                    };\n                    scriptTag.onerror = rej;\n                });\n\n                target.appendChild(scriptTag);\n                return promise;\n            })\n        );\n    } finally {\n        lock.release();\n    }\n}\n\n/**\n * Adds links to CSS files to the DOM of the target element. If a stylesheet was\n * already added to the target element, it is not added a second time.\n * @param styles a list of URLs to stylesheets to add\n * @param target the element to which the scripts should be added\n * @param addFontsToHead if true, @font-face rules found in the loaded\n * stylesheets will also be duplicated and added to the head of the document.\n * This is necessary to load fonts that should be displayed inside the shadow\n * DOM.\n */\nexport function addStylesheets(styles: string[], target: HTMLElement): void {\n    const existingTargetStylesheets = Array.from(\n        target.getElementsByTagName('link')\n    ).map((el) => el.dataset.h5pHref);\n\n    for (const styleUrl of styles) {\n        // Only add stylesheets once\n        if (existingTargetStylesheets.some((h5pHref) => h5pHref === styleUrl)) {\n            continue;\n        }\n        const stylesheet = document.createElement('link');\n        // We store the original href in the data-h5p-attribute as the browser\n        // internally adds the protocol and hostname to the href attribute.\n        stylesheet.dataset.h5pHref = styleUrl;\n        stylesheet.rel = 'stylesheet';\n        stylesheet.href = styleUrl;\n        stylesheet.type = 'text/css';\n        target.appendChild(stylesheet);\n    }\n}\n"],"mappings":"AAAA,OAAOA,SAAS,MAAM,YAAY;AAElC,MAAMC,IAAI,GAAG,IAAID,SAAS,EAAE;AAE5B;;;;;;;;AAQA,OAAO,eAAeE,UAAUA,CAC5BC,OAAiB,EACjBC,MAAmB;EAEnB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMH,IAAI,CAACI,YAAY,EAAE;EACzB,IAAI;IACA,MAAMC,eAAe,GAAGC,KAAK,CAACC,IAAI,CAC9BJ,MAAM,CAACK,oBAAoB,CAAC,QAAQ,CAAC,CACxC,CAACC,GAAG,CAAEC,EAAE,IAAKA,EAAE,CAACC,OAAO,CAACC,MAAM,CAAC;IAChC,MAAMC,OAAO,CAACC,GAAG,CACbZ,OAAO,CAACO,GAAG,CAAEM,SAAS,IAAI;MACtB;MACA,IACIV,eAAe,CAACW,IAAI,CACfC,WAAW,IAAKA,WAAW,KAAKF,SAAS,CAC7C,EACH;QACE,OAAOF,OAAO,CAACK,OAAO,EAAE;;MAE5B,MAAMC,SAAS,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;MAClDF,SAAS,CAACG,GAAG,GAAGP,SAAS;MACzB;MACA;MACAI,SAAS,CAACR,OAAO,CAACC,MAAM,GAAGG,SAAS;MACpCI,SAAS,CAACI,KAAK,GAAG,KAAK;MACvBJ,SAAS,CAACK,KAAK,GAAG,IAAI;MACtB,MAAMC,OAAO,GAAG,IAAIZ,OAAO,CAAO,CAACa,GAAG,EAAEC,GAAG,KAAI;QAC3CR,SAAS,CAACS,MAAM,GAAG,MAAW;UAC1BF,GAAG,EAAE;QACT,CAAC;QACDP,SAAS,CAACU,OAAO,GAAGF,GAAG;MAC3B,CAAC,CAAC;MAEFxB,MAAM,CAAC2B,WAAW,CAACX,SAAS,CAAC;MAC7B,OAAOM,OAAO;IAClB,CAAC,CAAC,CACL;GACJ,SAAS;IACNzB,IAAI,CAAC+B,OAAO,EAAE;;AAEtB;AAEA;;;;;;;;;;AAUA,OAAM,SAAUC,cAAcA,CAACC,MAAgB,EAAE9B,MAAmB;EAChE,MAAM+B,yBAAyB,GAAG5B,KAAK,CAACC,IAAI,CACxCJ,MAAM,CAACK,oBAAoB,CAAC,MAAM,CAAC,CACtC,CAACC,GAAG,CAAEC,EAAE,IAAKA,EAAE,CAACC,OAAO,CAACwB,OAAO,CAAC;EAEjC,KAAK,MAAMC,QAAQ,IAAIH,MAAM,EAAE;IAC3B;IACA,IAAIC,yBAAyB,CAAClB,IAAI,CAAEmB,OAAO,IAAKA,OAAO,KAAKC,QAAQ,CAAC,EAAE;MACnE;;IAEJ,MAAMC,UAAU,GAAGjB,QAAQ,CAACC,aAAa,CAAC,MAAM,CAAC;IACjD;IACA;IACAgB,UAAU,CAAC1B,OAAO,CAACwB,OAAO,GAAGC,QAAQ;IACrCC,UAAU,CAACC,GAAG,GAAG,YAAY;IAC7BD,UAAU,CAACE,IAAI,GAAGH,QAAQ;IAC1BC,UAAU,CAACG,IAAI,GAAG,UAAU;IAC5BrC,MAAM,CAAC2B,WAAW,CAACO,UAAU,CAAC;;AAEtC"},"metadata":{},"sourceType":"module","externalDependencies":[]}