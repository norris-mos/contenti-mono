{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _AwaitLock_acquired, _AwaitLock_waitingResolvers;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * A mutex lock for coordination across async functions\n */\nclass AwaitLock {\n  constructor() {\n    _AwaitLock_acquired.set(this, false);\n    _AwaitLock_waitingResolvers.set(this, new Set());\n  }\n  /**\n   * Whether the lock is currently acquired or not. Accessing this property does not affect the\n   * status of the lock.\n   */\n  get acquired() {\n    return __classPrivateFieldGet(this, _AwaitLock_acquired, \"f\");\n  }\n  /**\n   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The\n   * returned promise is fulfilled once the lock is acquired.\n   *\n   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before\n   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid\n   * timeout values depends on how `setTimeout` handles those values.\n   *\n   * After acquiring the lock, you **must** call `release` when you are done with it.\n   */\n  acquireAsync() {\n    let {\n      timeout\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n      __classPrivateFieldSet(this, _AwaitLock_acquired, true, \"f\");\n      return Promise.resolve();\n    }\n    if (timeout == null) {\n      return new Promise(resolve => {\n        __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").add(resolve);\n      });\n    }\n    let resolver;\n    let timer;\n    return Promise.race([new Promise(resolve => {\n      resolver = () => {\n        clearTimeout(timer);\n        resolve();\n      };\n      __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").add(resolver);\n    }), new Promise((_, reject) => {\n      timer = setTimeout(() => {\n        __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").delete(resolver);\n        reject(new Error(`Timed out waiting for lock`));\n      }, timeout);\n    })]);\n  }\n  /**\n   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns\n   * `true` if the lock was free and is now acquired, and `false` otherwise.\n   *\n   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs\n   * synchronously without waiting for the JavaScript task queue.\n   */\n  tryAcquire() {\n    if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n      __classPrivateFieldSet(this, _AwaitLock_acquired, true, \"f\");\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer\n   * must release the lock exactly once.\n   */\n  release() {\n    if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n      throw new Error(`Cannot release an unacquired lock`);\n    }\n    if (__classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").size > 0) {\n      // Sets preserve insertion order like a queue\n      const [resolve] = __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\");\n      __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").delete(resolve);\n      resolve();\n    } else {\n      __classPrivateFieldSet(this, _AwaitLock_acquired, false, \"f\");\n    }\n  }\n}\nexports.default = AwaitLock;\n_AwaitLock_acquired = new WeakMap(), _AwaitLock_waitingResolvers = new WeakMap();","map":{"version":3,"names":["AwaitLock","constructor","_AwaitLock_acquired","set","_AwaitLock_waitingResolvers","Set","acquired","__classPrivateFieldGet","acquireAsync","timeout","arguments","length","undefined","__classPrivateFieldSet","Promise","resolve","add","resolver","timer","race","clearTimeout","_","reject","setTimeout","delete","Error","tryAcquire","release","size","exports","default"],"sources":["/Users/maxoliverstapyltonnorris/contenti-mono/h5p-rest-example-client/node_modules/await-lock/src/AwaitLock.ts"],"sourcesContent":["/**\n * A mutex lock for coordination across async functions\n */\nexport default class AwaitLock {\n  #acquired: boolean = false;\n  #waitingResolvers: Set<() => void> = new Set();\n\n  /**\n   * Whether the lock is currently acquired or not. Accessing this property does not affect the\n   * status of the lock.\n   */\n  get acquired(): boolean {\n    return this.#acquired;\n  }\n\n  /**\n   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The\n   * returned promise is fulfilled once the lock is acquired.\n   *\n   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before\n   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid\n   * timeout values depends on how `setTimeout` handles those values.\n   *\n   * After acquiring the lock, you **must** call `release` when you are done with it.\n   */\n  acquireAsync({ timeout }: { timeout?: number } = {}): Promise<void> {\n    if (!this.#acquired) {\n      this.#acquired = true;\n      return Promise.resolve();\n    }\n\n    if (timeout == null) {\n      return new Promise((resolve) => {\n        this.#waitingResolvers.add(resolve);\n      });\n    }\n\n    let resolver: () => void;\n    let timer: ReturnType<typeof setTimeout>;\n\n    return Promise.race<void>([\n      new Promise((resolve) => {\n        resolver = () => {\n          clearTimeout(timer);\n          resolve();\n        };\n        this.#waitingResolvers.add(resolver);\n      }),\n      new Promise<void>((_, reject) => {\n        timer = setTimeout(() => {\n          this.#waitingResolvers.delete(resolver);\n          reject(new Error(`Timed out waiting for lock`));\n        }, timeout);\n      }),\n    ]);\n  }\n\n  /**\n   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns\n   * `true` if the lock was free and is now acquired, and `false` otherwise.\n   *\n   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs\n   * synchronously without waiting for the JavaScript task queue.\n   */\n  tryAcquire(): boolean {\n    if (!this.#acquired) {\n      this.#acquired = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer\n   * must release the lock exactly once.\n   */\n  release(): void {\n    if (!this.#acquired) {\n      throw new Error(`Cannot release an unacquired lock`);\n    }\n\n    if (this.#waitingResolvers.size > 0) {\n      // Sets preserve insertion order like a queue\n      const [resolve] = this.#waitingResolvers;\n      this.#waitingResolvers.delete(resolve);\n      resolve();\n    } else {\n      this.#acquired = false;\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;;;AAGA,MAAqBA,SAAS;EAA9BC,YAAA;IACEC,mBAAA,CAAAC,GAAA,OAAqB,KAAK;IAC1BC,2BAAA,CAAAD,GAAA,OAAqC,IAAIE,GAAG,EAAE;EAsFhD;EApFE;;;;EAIA,IAAIC,QAAQA,CAAA;IACV,OAAOC,sBAAA,KAAI,EAAAL,mBAAA,MAAU;EACvB;EAEA;;;;;;;;;;EAUAM,YAAYA,CAAA,EAAuC;IAAA,IAAtC;MAAEC;IAAO,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;IACjD,IAAI,CAACH,sBAAA,KAAI,EAAAL,mBAAA,MAAU,EAAE;MACnBW,sBAAA,KAAI,EAAAX,mBAAA,EAAa,IAAI;MACrB,OAAOY,OAAO,CAACC,OAAO,EAAE;;IAG1B,IAAIN,OAAO,IAAI,IAAI,EAAE;MACnB,OAAO,IAAIK,OAAO,CAAEC,OAAO,IAAI;QAC7BR,sBAAA,KAAI,EAAAH,2BAAA,MAAkB,CAACY,GAAG,CAACD,OAAO,CAAC;MACrC,CAAC,CAAC;;IAGJ,IAAIE,QAAoB;IACxB,IAAIC,KAAoC;IAExC,OAAOJ,OAAO,CAACK,IAAI,CAAO,CACxB,IAAIL,OAAO,CAAEC,OAAO,IAAI;MACtBE,QAAQ,GAAGA,CAAA,KAAK;QACdG,YAAY,CAACF,KAAK,CAAC;QACnBH,OAAO,EAAE;MACX,CAAC;MACDR,sBAAA,KAAI,EAAAH,2BAAA,MAAkB,CAACY,GAAG,CAACC,QAAQ,CAAC;IACtC,CAAC,CAAC,EACF,IAAIH,OAAO,CAAO,CAACO,CAAC,EAAEC,MAAM,KAAI;MAC9BJ,KAAK,GAAGK,UAAU,CAAC,MAAK;QACtBhB,sBAAA,KAAI,EAAAH,2BAAA,MAAkB,CAACoB,MAAM,CAACP,QAAQ,CAAC;QACvCK,MAAM,CAAC,IAAIG,KAAK,CAAC,4BAA4B,CAAC,CAAC;MACjD,CAAC,EAAEhB,OAAO,CAAC;IACb,CAAC,CAAC,CACH,CAAC;EACJ;EAEA;;;;;;;EAOAiB,UAAUA,CAAA;IACR,IAAI,CAACnB,sBAAA,KAAI,EAAAL,mBAAA,MAAU,EAAE;MACnBW,sBAAA,KAAI,EAAAX,mBAAA,EAAa,IAAI;MACrB,OAAO,IAAI;;IAGb,OAAO,KAAK;EACd;EAEA;;;;EAIAyB,OAAOA,CAAA;IACL,IAAI,CAACpB,sBAAA,KAAI,EAAAL,mBAAA,MAAU,EAAE;MACnB,MAAM,IAAIuB,KAAK,CAAC,mCAAmC,CAAC;;IAGtD,IAAIlB,sBAAA,KAAI,EAAAH,2BAAA,MAAkB,CAACwB,IAAI,GAAG,CAAC,EAAE;MACnC;MACA,MAAM,CAACb,OAAO,CAAC,GAAGR,sBAAA,KAAI,EAAAH,2BAAA,MAAkB;MACxCG,sBAAA,KAAI,EAAAH,2BAAA,MAAkB,CAACoB,MAAM,CAACT,OAAO,CAAC;MACtCA,OAAO,EAAE;KACV,MAAM;MACLF,sBAAA,KAAI,EAAAX,mBAAA,EAAa,KAAK;;EAE1B;;AAvFF2B,OAAA,CAAAC,OAAA,GAAA9B,SAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}