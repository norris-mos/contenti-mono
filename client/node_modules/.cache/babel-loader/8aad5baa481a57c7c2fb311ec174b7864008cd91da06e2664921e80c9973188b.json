{"ast":null,"code":"export class ContentService {\n  /**\n   *\n   */\n\n  // THIS IS NORMALLU EMPTY\n  constructor() {\n    let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http://localhost:8080/';\n    this.baseUrl = baseUrl;\n    this.csrfToken = undefined;\n    this.delete = async contentId => {\n      var _this$csrfToken;\n      console.log(`ContentService: deleting ${contentId}...`);\n      const result = await fetch(`${this.baseUrl}/${contentId}`, {\n        method: 'delete',\n        headers: {\n          'CSRF-Token': (_this$csrfToken = this.csrfToken) !== null && _this$csrfToken !== void 0 ? _this$csrfToken : ''\n        }\n      });\n      if (!result.ok) {\n        throw new Error(`Error while deleting content: ${result.status} ${result.statusText} ${await result.text()}`);\n      }\n    };\n    this.getEdit = async contentId => {\n      console.log(`ContentService: Getting information to edit ${contentId}...`);\n      const res = await fetch(`${this.baseUrl}/${contentId}/edit`);\n      if (!res || !res.ok) {\n        throw new Error(`${res.status} ${res.statusText}`);\n      }\n      return res.json();\n    };\n    this.getPlay = async contentId => {\n      console.log(`ContentService: Getting information to play ${contentId}...`);\n      console.log(`${this.baseUrl}/${contentId}/play`);\n      const res = await fetch(`${this.baseUrl}/${contentId}/play`);\n      if (!res || !res.ok) {\n        throw new Error(`${res.status} ${res.statusText}`);\n      }\n      return res.json();\n    };\n    this.list = async () => {\n      console.log(`ContentService: Listing content objects`);\n      const result = await fetch(this.baseUrl);\n      if (result.ok) {\n        return result.json();\n      }\n      throw new Error(`Request to REST endpoint returned ${result.status} ${result.statusText}: ${await result.text()}`);\n    };\n    this.prompt = async (prompt, contenttype) => {\n      console.log('Generating content...');\n      const result = await fetch(`${this.baseUrl}/prompt/${contenttype}`);\n      const requestbod = {\n        method: 'POST',\n        headers: {}\n      };\n      if (!result || !result.ok) {\n        throw new Error(`${result.status} ${result.statusText}`);\n      }\n      return result.json();\n    };\n    this.save = async (contentId, requestBody) => {\n      var _this$csrfToken2, _this$csrfToken3, _this$csrfToken4;\n      if (contentId) {\n        console.log(`ContentService: Saving new content.`);\n      } else {\n        console.log(`csrrf is ${this.csrfToken}`);\n        console.log(`the content id is ${contentId} i think`);\n        console.log(`ContentService: Savin content ${contentId}`);\n      }\n      const body = JSON.stringify(requestBody);\n      console.log(body);\n      const requestbod = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'CSRF-Token': (_this$csrfToken2 = this.csrfToken) !== null && _this$csrfToken2 !== void 0 ? _this$csrfToken2 : ''\n        },\n        body: body\n      };\n      console.log(requestbod);\n      const res = contentId ? await fetch(`${this.baseUrl}/${contentId}`, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'CSRF-Token': (_this$csrfToken3 = this.csrfToken) !== null && _this$csrfToken3 !== void 0 ? _this$csrfToken3 : ''\n        },\n        body\n      }) : await fetch(this.baseUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'CSRF-Token': (_this$csrfToken4 = this.csrfToken) !== null && _this$csrfToken4 !== void 0 ? _this$csrfToken4 : ''\n        },\n        //credentials: 'include',\n        body\n      });\n      if (!res || !res.ok) {\n        throw new Error(`${res.status} ${res.statusText} - ${await res.text()}`);\n      }\n      return res.json();\n    };\n    this.generateDownloadLink = contentId => `${this.baseUrl}/download/${contentId}`;\n    this.setCsrfToken = csrfToken => {\n      this.csrfToken = csrfToken;\n    };\n    this.getCsrfToken = () => {\n      return this.csrfToken;\n    };\n  }\n}","map":{"version":3,"names":["ContentService","constructor","baseUrl","arguments","length","undefined","csrfToken","delete","contentId","_this$csrfToken","console","log","result","fetch","method","headers","ok","Error","status","statusText","text","getEdit","res","json","getPlay","list","prompt","contenttype","requestbod","save","requestBody","_this$csrfToken2","_this$csrfToken3","_this$csrfToken4","body","JSON","stringify","generateDownloadLink","setCsrfToken","getCsrfToken"],"sources":["/Users/maxoliverstapyltonnorris/contenti-mono/client/src/services/ContentService.ts"],"sourcesContent":["import type {\n  IEditorModel,\n  IPlayerModel,\n  IContentMetadata,\n} from '@lumieducation/h5p-server';\n\nexport interface IContentListEntry {\n  contentId: string;\n  mainLibrary: string;\n  title: string;\n  originalNewKey?: string;\n}\n\nexport interface IContentService {\n  delete(contentId: string): Promise<void>;\n  getEdit(contentId: string): Promise<IEditorModel>;\n  getPlay(contentId: string): Promise<IPlayerModel>;\n  list(): Promise<IContentListEntry[]>;\n  save(\n    contentId: string,\n    requestBody: { library: string; params: any }\n  ): Promise<{ contentId: string; metadata: IContentMetadata }>;\n  prompt(\n    prompt: string,\n    contenttype: string\n  ): Promise<{ contentId: string; metadata: IContentMetadata }>;\n  generateDownloadLink(contentId: string): string;\n}\n\nexport class ContentService implements IContentService {\n  /**\n   *\n   */\n\n  // THIS IS NORMALLU EMPTY\n  constructor(protected baseUrl: string = 'http://localhost:8080/') {}\n\n  private csrfToken: string | undefined = undefined;\n\n  delete = async (contentId: string): Promise<void> => {\n    console.log(`ContentService: deleting ${contentId}...`);\n    const result = await fetch(`${this.baseUrl}/${contentId}`, {\n      method: 'delete',\n      headers: {\n        'CSRF-Token': this.csrfToken ?? '',\n      },\n    });\n    if (!result.ok) {\n      throw new Error(\n        `Error while deleting content: ${result.status} ${\n          result.statusText\n        } ${await result.text()}`\n      );\n    }\n  };\n\n  getEdit = async (contentId: string): Promise<IEditorModel> => {\n    console.log(`ContentService: Getting information to edit ${contentId}...`);\n    const res = await fetch(`${this.baseUrl}/${contentId}/edit`);\n    if (!res || !res.ok) {\n      throw new Error(`${res.status} ${res.statusText}`);\n    }\n    return res.json();\n  };\n\n  getPlay = async (contentId: string): Promise<IPlayerModel> => {\n    console.log(`ContentService: Getting information to play ${contentId}...`);\n    console.log(`${this.baseUrl}/${contentId}/play`);\n    const res = await fetch(`${this.baseUrl}/${contentId}/play`);\n    if (!res || !res.ok) {\n      throw new Error(`${res.status} ${res.statusText}`);\n    }\n    return res.json();\n  };\n\n  list = async (): Promise<IContentListEntry[]> => {\n    console.log(`ContentService: Listing content objects`);\n    const result = await fetch(this.baseUrl);\n    if (result.ok) {\n      return result.json();\n    }\n    throw new Error(\n      `Request to REST endpoint returned ${result.status} ${\n        result.statusText\n      }: ${await result.text()}`\n    );\n  };\n\n  prompt = async (\n    prompt: string,\n    contenttype: string\n  ): Promise<{ contentId: string; metadata: IContentMetadata }> => {\n    console.log('Generating content...');\n    const result = await fetch(`${this.baseUrl}/prompt/${contenttype}`);\n\n    const requestbod = {\n      method: 'POST',\n      headers: {},\n    };\n    if (!result || !result.ok) {\n      throw new Error(`${result.status} ${result.statusText}`);\n    }\n    return result.json();\n  };\n\n  save = async (\n    contentId: string,\n    requestBody: { library: string; params: any }\n  ): Promise<{ contentId: string; metadata: IContentMetadata }> => {\n    if (contentId) {\n      console.log(`ContentService: Saving new content.`);\n    } else {\n      console.log(`csrrf is ${this.csrfToken}`);\n      console.log(`the content id is ${contentId} i think`);\n      console.log(`ContentService: Savin content ${contentId}`);\n    }\n\n    const body = JSON.stringify(requestBody);\n    console.log(body);\n\n    const requestbod = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'CSRF-Token': this.csrfToken ?? '',\n      },\n      body: body,\n    };\n    console.log(requestbod);\n\n    const res = contentId\n      ? await fetch(`${this.baseUrl}/${contentId}`, {\n          method: 'PATCH',\n          headers: {\n            'Content-Type': 'application/json',\n            'CSRF-Token': this.csrfToken ?? '',\n          },\n          body,\n        })\n      : await fetch(this.baseUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'CSRF-Token': this.csrfToken ?? '',\n          },\n          //credentials: 'include',\n          body,\n        });\n\n    if (!res || !res.ok) {\n      throw new Error(`${res.status} ${res.statusText} - ${await res.text()}`);\n    }\n    return res.json();\n  };\n  generateDownloadLink = (contentId: string): string =>\n    `${this.baseUrl}/download/${contentId}`;\n\n  setCsrfToken = (csrfToken: string | undefined): void => {\n    this.csrfToken = csrfToken;\n  };\n  getCsrfToken = (): string | undefined => {\n    return this.csrfToken;\n  };\n}\n"],"mappings":"AA6BA,OAAO,MAAMA,cAAc,CAA4B;EACrD;AACF;AACA;;EAEE;EACAC,WAAWA,CAAA,EAAuD;IAAA,IAA5CC,OAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,wBAAwB;IAAA,KAA1CD,OAAe,GAAfA,OAAe;IAAA,KAE7BI,SAAS,GAAuBD,SAAS;IAAA,KAEjDE,MAAM,GAAG,MAAOC,SAAiB,IAAoB;MAAA,IAAAC,eAAA;MACnDC,OAAO,CAACC,GAAG,CAAE,4BAA2BH,SAAU,KAAI,CAAC;MACvD,MAAMI,MAAM,GAAG,MAAMC,KAAK,CAAE,GAAE,IAAI,CAACX,OAAQ,IAAGM,SAAU,EAAC,EAAE;QACzDM,MAAM,EAAE,QAAQ;QAChBC,OAAO,EAAE;UACP,YAAY,GAAAN,eAAA,GAAE,IAAI,CAACH,SAAS,cAAAG,eAAA,cAAAA,eAAA,GAAI;QAClC;MACF,CAAC,CAAC;MACF,IAAI,CAACG,MAAM,CAACI,EAAE,EAAE;QACd,MAAM,IAAIC,KAAK,CACZ,iCAAgCL,MAAM,CAACM,MAAO,IAC7CN,MAAM,CAACO,UACR,IAAG,MAAMP,MAAM,CAACQ,IAAI,CAAC,CAAE,EAC1B,CAAC;MACH;IACF,CAAC;IAAA,KAEDC,OAAO,GAAG,MAAOb,SAAiB,IAA4B;MAC5DE,OAAO,CAACC,GAAG,CAAE,+CAA8CH,SAAU,KAAI,CAAC;MAC1E,MAAMc,GAAG,GAAG,MAAMT,KAAK,CAAE,GAAE,IAAI,CAACX,OAAQ,IAAGM,SAAU,OAAM,CAAC;MAC5D,IAAI,CAACc,GAAG,IAAI,CAACA,GAAG,CAACN,EAAE,EAAE;QACnB,MAAM,IAAIC,KAAK,CAAE,GAAEK,GAAG,CAACJ,MAAO,IAAGI,GAAG,CAACH,UAAW,EAAC,CAAC;MACpD;MACA,OAAOG,GAAG,CAACC,IAAI,CAAC,CAAC;IACnB,CAAC;IAAA,KAEDC,OAAO,GAAG,MAAOhB,SAAiB,IAA4B;MAC5DE,OAAO,CAACC,GAAG,CAAE,+CAA8CH,SAAU,KAAI,CAAC;MAC1EE,OAAO,CAACC,GAAG,CAAE,GAAE,IAAI,CAACT,OAAQ,IAAGM,SAAU,OAAM,CAAC;MAChD,MAAMc,GAAG,GAAG,MAAMT,KAAK,CAAE,GAAE,IAAI,CAACX,OAAQ,IAAGM,SAAU,OAAM,CAAC;MAC5D,IAAI,CAACc,GAAG,IAAI,CAACA,GAAG,CAACN,EAAE,EAAE;QACnB,MAAM,IAAIC,KAAK,CAAE,GAAEK,GAAG,CAACJ,MAAO,IAAGI,GAAG,CAACH,UAAW,EAAC,CAAC;MACpD;MACA,OAAOG,GAAG,CAACC,IAAI,CAAC,CAAC;IACnB,CAAC;IAAA,KAEDE,IAAI,GAAG,YAA0C;MAC/Cf,OAAO,CAACC,GAAG,CAAE,yCAAwC,CAAC;MACtD,MAAMC,MAAM,GAAG,MAAMC,KAAK,CAAC,IAAI,CAACX,OAAO,CAAC;MACxC,IAAIU,MAAM,CAACI,EAAE,EAAE;QACb,OAAOJ,MAAM,CAACW,IAAI,CAAC,CAAC;MACtB;MACA,MAAM,IAAIN,KAAK,CACZ,qCAAoCL,MAAM,CAACM,MAAO,IACjDN,MAAM,CAACO,UACR,KAAI,MAAMP,MAAM,CAACQ,IAAI,CAAC,CAAE,EAC3B,CAAC;IACH,CAAC;IAAA,KAEDM,MAAM,GAAG,OACPA,MAAc,EACdC,WAAmB,KAC4C;MAC/DjB,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;MACpC,MAAMC,MAAM,GAAG,MAAMC,KAAK,CAAE,GAAE,IAAI,CAACX,OAAQ,WAAUyB,WAAY,EAAC,CAAC;MAEnE,MAAMC,UAAU,GAAG;QACjBd,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE,CAAC;MACZ,CAAC;MACD,IAAI,CAACH,MAAM,IAAI,CAACA,MAAM,CAACI,EAAE,EAAE;QACzB,MAAM,IAAIC,KAAK,CAAE,GAAEL,MAAM,CAACM,MAAO,IAAGN,MAAM,CAACO,UAAW,EAAC,CAAC;MAC1D;MACA,OAAOP,MAAM,CAACW,IAAI,CAAC,CAAC;IACtB,CAAC;IAAA,KAEDM,IAAI,GAAG,OACLrB,SAAiB,EACjBsB,WAA6C,KACkB;MAAA,IAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA;MAC/D,IAAIzB,SAAS,EAAE;QACbE,OAAO,CAACC,GAAG,CAAE,qCAAoC,CAAC;MACpD,CAAC,MAAM;QACLD,OAAO,CAACC,GAAG,CAAE,YAAW,IAAI,CAACL,SAAU,EAAC,CAAC;QACzCI,OAAO,CAACC,GAAG,CAAE,qBAAoBH,SAAU,UAAS,CAAC;QACrDE,OAAO,CAACC,GAAG,CAAE,iCAAgCH,SAAU,EAAC,CAAC;MAC3D;MAEA,MAAM0B,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACN,WAAW,CAAC;MACxCpB,OAAO,CAACC,GAAG,CAACuB,IAAI,CAAC;MAEjB,MAAMN,UAAU,GAAG;QACjBd,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,YAAY,GAAAgB,gBAAA,GAAE,IAAI,CAACzB,SAAS,cAAAyB,gBAAA,cAAAA,gBAAA,GAAI;QAClC,CAAC;QACDG,IAAI,EAAEA;MACR,CAAC;MACDxB,OAAO,CAACC,GAAG,CAACiB,UAAU,CAAC;MAEvB,MAAMN,GAAG,GAAGd,SAAS,GACjB,MAAMK,KAAK,CAAE,GAAE,IAAI,CAACX,OAAQ,IAAGM,SAAU,EAAC,EAAE;QAC1CM,MAAM,EAAE,OAAO;QACfC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,YAAY,GAAAiB,gBAAA,GAAE,IAAI,CAAC1B,SAAS,cAAA0B,gBAAA,cAAAA,gBAAA,GAAI;QAClC,CAAC;QACDE;MACF,CAAC,CAAC,GACF,MAAMrB,KAAK,CAAC,IAAI,CAACX,OAAO,EAAE;QACxBY,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,YAAY,GAAAkB,gBAAA,GAAE,IAAI,CAAC3B,SAAS,cAAA2B,gBAAA,cAAAA,gBAAA,GAAI;QAClC,CAAC;QACD;QACAC;MACF,CAAC,CAAC;MAEN,IAAI,CAACZ,GAAG,IAAI,CAACA,GAAG,CAACN,EAAE,EAAE;QACnB,MAAM,IAAIC,KAAK,CAAE,GAAEK,GAAG,CAACJ,MAAO,IAAGI,GAAG,CAACH,UAAW,MAAK,MAAMG,GAAG,CAACF,IAAI,CAAC,CAAE,EAAC,CAAC;MAC1E;MACA,OAAOE,GAAG,CAACC,IAAI,CAAC,CAAC;IACnB,CAAC;IAAA,KACDc,oBAAoB,GAAI7B,SAAiB,IACtC,GAAE,IAAI,CAACN,OAAQ,aAAYM,SAAU,EAAC;IAAA,KAEzC8B,YAAY,GAAIhC,SAA6B,IAAW;MACtD,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC5B,CAAC;IAAA,KACDiC,YAAY,GAAG,MAA0B;MACvC,OAAO,IAAI,CAACjC,SAAS;IACvB,CAAC;EA/HkE;AAgIrE"},"metadata":{},"sourceType":"module","externalDependencies":[]}