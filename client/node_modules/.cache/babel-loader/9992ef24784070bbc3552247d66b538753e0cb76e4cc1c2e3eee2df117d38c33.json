{"ast":null,"code":"import { mergeH5PIntegration } from './h5p-utils';\nimport { addScripts } from './dom-utils';\nexport class H5PEditorComponent extends HTMLElement {\n  constructor() {\n    super();\n    /**\n     * Call this method when the iframe containing the editor needs to be\n     * resized, e.g. because the some\n     */\n    this.resize = () => {\n      var _a, _b, _c;\n      const h5pEditorIframe = this.querySelector('.h5p-editor-iframe');\n      if (h5pEditorIframe) {\n        const newHeight = (_c = (_b = (_a = h5pEditorIframe.contentWindow) === null || _a === void 0 ? void 0 : _a.document) === null || _b === void 0 ? void 0 : _b.body) === null || _c === void 0 ? void 0 : _c.scrollHeight;\n        if (newHeight !== undefined) {\n          h5pEditorIframe.style.height = `${h5pEditorIframe.contentWindow.document.body.scrollHeight.toString()}px`;\n        }\n      }\n    };\n    /**\n     * Call save() to get data from the H5P editor and send it to the server.\n     * You can use the saveContentCallback hook to customize server requests.\n     * The component emits 'saved', 'save-error' and 'validation-error' events,\n     * depending on success of the function. You can subscribe to those or use\n     * the promise's return value and catch the errors in a try-catch block.\n     * @throws an error if something went wrong\n     * @returns the contentId and metadata of the saved content\n     */\n    this.save = async () => {\n      if (this.editorInstance === undefined) {\n        this.dispatchAndThrowError('save-error', 'editorInstance of h5p editor not defined.');\n      }\n      if (!this.saveContentCallback) {\n        this.dispatchAndThrowError('save-error', 'saveContentCallback of H5P Editor Web Component not defined.');\n      }\n      // Get parameters (and also validates them as a side effect)\n      const params = this.editorInstance.getParams();\n      if (!params.params) {\n        this.dispatchAndThrowError('validation-error', 'The parameters entered by the user are invalid.');\n      }\n      // Validate mandatory main title. Prevent submitting if that's not set.\n      // Deliberately doing it after getParams(), so that any other validation\n      // problems are also revealed.\n      if (!this.editorInstance.isMainTitleSet()) {\n        this.dispatchAndThrowError('validation-error', \"The main title of the content hasn't been set.\");\n      }\n      let content;\n      try {\n        content = await new Promise((res, rej) => {\n          // By calling getContent we also upgrade the content (this\n          // is an unexpected side effect)\n          this.editorInstance.getContent(c => {\n            res(c);\n          }, err => {\n            rej(err);\n          });\n        });\n      } catch (error) {\n        this.dispatchAndThrowError('validation-error', error.toString());\n      }\n      let saveResponseObject;\n      const requestBody = {\n        library: content.library,\n        params: JSON.parse(content.params)\n      };\n      try {\n        saveResponseObject = await this.saveContentCallback(this.contentId === 'new' ? undefined : this.contentId, requestBody);\n      } catch (error) {\n        this.dispatchAndThrowError('save-error', error.message);\n      }\n      if (this.contentId !== saveResponseObject.contentId) {\n        this.setAttribute('content-id', saveResponseObject.contentId);\n      }\n      this.dispatchEvent(new CustomEvent('saved', {\n        detail: {\n          contentId: saveResponseObject.contentId,\n          metadata: saveResponseObject.metadata\n        }\n      }));\n      return saveResponseObject;\n    };\n    /**\n     * Called by the global H5P event dispatcher when any editor was loaded.\n     */\n    this.onEditorLoaded = event => {\n      var _a;\n      // We must manually check if our editor instance is initialized, as the\n      // event is only sent globally.\n      if (this.editorInstance.selector.form) {\n        this.dispatchEvent(new CustomEvent('editorloaded', {\n          detail: {\n            contentId: this.contentId,\n            ubername: event.data\n          }\n        }));\n        // After our editor has been initialized, it will never fire the\n        // global event again, so we can unsubscribe from it.\n        if ((_a = window.H5P) === null || _a === void 0 ? void 0 : _a.externalDispatcher) {\n          window.H5P.externalDispatcher.off('editorloaded', this.onEditorLoaded);\n        }\n      }\n    };\n    H5PEditorComponent.initTemplate();\n  }\n  get contentId() {\n    var _a;\n    return (_a = this.getAttribute('content-id')) !== null && _a !== void 0 ? _a : undefined;\n  }\n  set contentId(contentId) {\n    if (!contentId) {\n      this.removeAttribute('content-id');\n    } else {\n      this.setAttribute('content-id', contentId);\n    }\n  }\n  /**\n   * Called when the component needs to load data about content. The endpoint\n   * called in here combines the results of H5PEditor.render(...) and\n   * H5PEditor.getContent(...) to avoid too many requests.\n   *\n   * Note that the library, metadata and params property of the returned\n   * object must only be defined if contentId is defined.\n   *\n   * Should throw an error with a message in the message property if something\n   * goes wrong.\n   */\n  get loadContentCallback() {\n    return this.privateLoadContentCallback;\n  }\n  set loadContentCallback(callback) {\n    // We only (re-)render the component if the callback was really changed.\n    const mustRender = this.privateLoadContentCallback !== callback;\n    this.privateLoadContentCallback = callback;\n    if (mustRender) {\n      this.render(this.contentId);\n    }\n  }\n  /**\n   * Indicates changes to which attributes should trigger calls to\n   * attributeChangedCallback.\n   */\n  static get observedAttributes() {\n    return ['content-id', 'h5p-url'];\n  }\n  static initTemplate() {\n    // We create the static template only once\n    if (!H5PEditorComponent.template) {\n      H5PEditorComponent.template = document.createElement('template');\n      H5PEditorComponent.template.innerHTML = `\n            <style>\n            .h5peditor-semi-fullscreen {\n                margin: 0;\n                padding: 0;\n                position: fixed;\n                overflow-y: scroll;\n                box-sizing: border-box;\n                height: 100%;\n                width: 100%;\n                left: 0;\n                top: 0;\n            }\n            </style>\n            <div class=\"h5p-editor-component-root\"></div>`;\n    }\n  }\n  /**\n   * Called when one of the attributes in observedAttributes changes.\n   */\n  async attributeChangedCallback(name, oldVal, newVal) {\n    // We don't render if the component's content id changes from 'new'\n    // to something else, as this would lead to flickering when saving\n    // newly created content.\n    if (name === 'content-id' && oldVal !== newVal && oldVal !== 'new') {\n      await this.render(newVal);\n    }\n  }\n  /**\n   * Called when the component is added to the DOM.\n   */\n  async connectedCallback() {\n    this.appendChild(H5PEditorComponent.template.content.cloneNode(true));\n    this.root = this.querySelector('.h5p-editor-component-root');\n    this.resizeObserver = new ResizeObserver(() => {\n      this.resize();\n    });\n    this.resizeObserver.observe(this);\n    await this.render(this.contentId);\n  }\n  /**\n   * Called when the component is removed from the DOM.\n   */\n  disconnectedCallback() {\n    var _a;\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    // Unregister our event listener from the global H5P dispatcher.\n    if ((_a = window.H5P) === null || _a === void 0 ? void 0 : _a.externalDispatcher) {\n      window.H5P.externalDispatcher.off('editorloaded', this.onEditorLoaded);\n    }\n  }\n  /**\n   * Dispatches an event of the specified name and throws an error whose error\n   * message starts with the eventName.\n   * @param eventName\n   * @param message\n   */\n  dispatchAndThrowError(eventName, message) {\n    this.dispatchEvent(new CustomEvent(eventName, {\n      detail: {\n        message\n      }\n    }));\n    throw new Error(`${eventName}: ${message}`);\n  }\n  /**\n   * Displays the editor inside the component by creating a new DOM tree.\n   * @param contentId the content id to display or undefined if a new piece\n   * of content was created\n   */\n  async render(contentId) {\n    if (!this.loadContentCallback) {\n      return;\n    }\n    if (!contentId) {\n      return;\n    }\n    let editorModel;\n    try {\n      editorModel = await this.loadContentCallback(contentId === 'new' ? undefined : contentId);\n    } catch (error) {\n      this.root.innerHTML = `<p>Error loading H5P content from server: ${error.message}`;\n      return;\n    }\n    // Reset DOM tree inside component.\n    this.root.innerHTML = '';\n    // We have to prevent H5P from initializing when the h5p.js file is\n    // loaded.\n    if (!window.H5P) {\n      window.H5P = {};\n    }\n    window.H5P.preventInit = true;\n    // We merge the H5P integration we received from the server with the one\n    // that already exists in the window globally to allow for several H5P\n    // content objects on a single page.\n    mergeH5PIntegration(editorModel.integration, contentId === 'new' ? undefined : contentId);\n    // As the editor adds an iframe anyway and styles don't really matter, we\n    // only add the global editor scripts to the whole page, but not the styles\n    // (to avoid side effects).\n    await addScripts(editorModel.scripts, document.getElementsByTagName('head')[0]);\n    // Create the necessary DOM tree.\n    const h5pCreateDiv = document.createElement('div');\n    h5pCreateDiv.className = 'h5p-create';\n    h5pCreateDiv.hidden = true;\n    this.root.appendChild(h5pCreateDiv);\n    const h5pEditorDiv = document.createElement('div');\n    h5pEditorDiv.className = 'h5p-editor';\n    h5pCreateDiv.appendChild(h5pEditorDiv);\n    // Set up the H5P core editor.\n    H5PEditor.getAjaxUrl = (action, parameters) => {\n      let url = editorModel.integration.editor.ajaxPath + action;\n      if (parameters !== undefined) {\n        for (const property in parameters) {\n          if (Object.prototype.hasOwnProperty.call(parameters, property)) {\n            url = `${url}&${property}=${parameters[property]}`;\n          }\n        }\n      }\n      url += window.location.search.replace(/\\\\?/g, '&');\n      return url;\n    };\n    window.H5P.preventInit = false;\n    // Only initialize H5P once to avoid resetting values.\n    if (!window.h5pIsInitialized) {\n      window.H5P.init(this.root);\n      window.h5pIsInitialized = true;\n    }\n    // Register our global editorloaded event handler.\n    if (window.H5P.externalDispatcher) {\n      window.H5P.externalDispatcher.on('editorloaded', this.onEditorLoaded, this);\n    }\n    // Configure the H5P core editor.\n    H5PEditor.$ = window.H5P.jQuery;\n    H5PEditor.basePath = editorModel.integration.editor.libraryUrl;\n    H5PEditor.fileIcon = editorModel.integration.editor.fileIcon;\n    H5PEditor.ajaxPath = editorModel.integration.editor.ajaxPath;\n    H5PEditor.filesPath = editorModel.integration.editor.filesPath;\n    H5PEditor.apiVersion = editorModel.integration.editor.apiVersion;\n    H5PEditor.contentLanguage = editorModel.integration.editor.language;\n    H5PEditor.copyrightSemantics = editorModel.integration.editor.copyrightSemantics;\n    H5PEditor.metadataSemantics = editorModel.integration.editor.metadataSemantics;\n    H5PEditor.assets = editorModel.integration.editor.assets;\n    H5PEditor.baseUrl = '';\n    H5PEditor.contentId = contentId === 'new' ? undefined : contentId;\n    H5PEditor.enableContentHub = editorModel.integration.editor.enableContentHub || false;\n    if (contentId === 'new') {\n      // Create an empty editor for new content\n      this.editorInstance = new ns.Editor(undefined, undefined, h5pEditorDiv);\n    } else {\n      // Load the editor with populated parameters for existing content\n      this.editorInstance = new ns.Editor(editorModel.library, JSON.stringify({\n        metadata: editorModel.metadata,\n        params: editorModel.params\n      }), h5pEditorDiv);\n    }\n    h5pCreateDiv.hidden = false;\n  }\n}","map":{"version":3,"names":["mergeH5PIntegration","addScripts","H5PEditorComponent","HTMLElement","constructor","resize","h5pEditorIframe","querySelector","newHeight","_c","_b","_a","contentWindow","document","body","scrollHeight","undefined","style","height","toString","save","editorInstance","dispatchAndThrowError","saveContentCallback","params","getParams","isMainTitleSet","content","Promise","res","rej","getContent","c","err","error","saveResponseObject","requestBody","library","JSON","parse","contentId","message","setAttribute","dispatchEvent","CustomEvent","detail","metadata","onEditorLoaded","event","selector","form","ubername","data","window","H5P","externalDispatcher","off","initTemplate","getAttribute","removeAttribute","loadContentCallback","privateLoadContentCallback","callback","mustRender","render","observedAttributes","template","createElement","innerHTML","attributeChangedCallback","name","oldVal","newVal","connectedCallback","appendChild","cloneNode","root","resizeObserver","ResizeObserver","observe","disconnectedCallback","disconnect","eventName","Error","editorModel","preventInit","integration","scripts","getElementsByTagName","h5pCreateDiv","className","hidden","h5pEditorDiv","H5PEditor","getAjaxUrl","action","parameters","url","editor","ajaxPath","property","Object","prototype","hasOwnProperty","call","location","search","replace","h5pIsInitialized","init","on","$","jQuery","basePath","libraryUrl","fileIcon","filesPath","apiVersion","contentLanguage","language","copyrightSemantics","metadataSemantics","assets","baseUrl","enableContentHub","ns","Editor","stringify"],"sources":["/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-webcomponents/src/h5p-editor.ts"],"sourcesContent":["import type { IEditorModel, IContentMetadata } from '@lumieducation/h5p-server';\n\nimport { mergeH5PIntegration } from './h5p-utils';\nimport { addScripts } from './dom-utils';\n\ndeclare global {\n    /**\n     * The H5P core \"class\" for the editor.\n     */\n    // eslint-disable-next-line vars-on-top, no-var\n    var H5PEditor;\n    /**\n     * Used by the H5P core for namespacing.\n     */\n    // eslint-disable-next-line vars-on-top, no-var\n    var ns;\n}\n\nexport class H5PEditorComponent extends HTMLElement {\n    constructor() {\n        super();\n\n        H5PEditorComponent.initTemplate();\n    }\n\n    public get contentId(): string {\n        return this.getAttribute('content-id') ?? undefined;\n    }\n\n    public set contentId(contentId: string) {\n        if (!contentId) {\n            this.removeAttribute('content-id');\n        } else {\n            this.setAttribute('content-id', contentId);\n        }\n    }\n\n    /**\n     * Called when the component needs to load data about content. The endpoint\n     * called in here combines the results of H5PEditor.render(...) and\n     * H5PEditor.getContent(...) to avoid too many requests.\n     *\n     * Note that the library, metadata and params property of the returned\n     * object must only be defined if contentId is defined.\n     *\n     * Should throw an error with a message in the message property if something\n     * goes wrong.\n     */\n    public get loadContentCallback(): (contentId: string) => Promise<\n        IEditorModel & {\n            library?: string;\n            metadata?: IContentMetadata;\n            params?: any;\n        }\n    > {\n        return this.privateLoadContentCallback;\n    }\n\n    public set loadContentCallback(\n        callback: (contentId: string) => Promise<\n            IEditorModel & {\n                library?: string;\n                metadata?: IContentMetadata;\n                params?: any;\n            }\n        >\n    ) {\n        // We only (re-)render the component if the callback was really changed.\n        const mustRender = this.privateLoadContentCallback !== callback;\n        this.privateLoadContentCallback = callback;\n        if (mustRender) {\n            this.render(this.contentId);\n        }\n    }\n\n    /**\n     * Indicates changes to which attributes should trigger calls to\n     * attributeChangedCallback.\n     */\n    public static get observedAttributes(): string[] {\n        return ['content-id', 'h5p-url'];\n    }\n\n    private static template: HTMLTemplateElement;\n\n    /**\n     * Called when the component needs to save data about content. The endpoint\n     * called here should call H5PEditor.saveOrUpdateContentReturnMetaData(...).\n     * Note that it makes sense to use PATCH requests for updates and POST\n     * requests for new content, but it's up to you how you implement this. See\n     * defaultSaveContentCallback for an example.\n     *\n     * Should throw an error with a message in the message property if something\n     * goes wrong.\n     * @param contentId the contentId which needs to be saved; can be undefined\n     * for new content, which hasn't been saved before\n     * @param requestBody the data needed by the server; usually encoded as JSON\n     * string and sent to the server\n     * @returns the newly assigned content id and metadata\n     */\n    public saveContentCallback: (\n        contentId: string,\n        requestBody: { library: string; params: any }\n    ) => Promise<{ contentId: string; metadata: IContentMetadata }>;\n\n    private editorInstance: any;\n    /**\n     * Stores the H5P instance (H5P native object of the core).\n     */\n\n    private privateLoadContentCallback: (contentId: string) => Promise<\n        IEditorModel & {\n            library?: string;\n            metadata?: IContentMetadata;\n            params?: any;\n        }\n    >;\n\n    private resizeObserver: ResizeObserver;\n\n    private root: HTMLElement;\n\n    private static initTemplate(): void {\n        // We create the static template only once\n        if (!H5PEditorComponent.template) {\n            H5PEditorComponent.template = document.createElement('template');\n            H5PEditorComponent.template.innerHTML = `\n            <style>\n            .h5peditor-semi-fullscreen {\n                margin: 0;\n                padding: 0;\n                position: fixed;\n                overflow-y: scroll;\n                box-sizing: border-box;\n                height: 100%;\n                width: 100%;\n                left: 0;\n                top: 0;\n            }\n            </style>\n            <div class=\"h5p-editor-component-root\"></div>`;\n        }\n    }\n\n    /**\n     * Called when one of the attributes in observedAttributes changes.\n     */\n    public async attributeChangedCallback(\n        name: string,\n        oldVal: any,\n        newVal: any\n    ): Promise<void> {\n        // We don't render if the component's content id changes from 'new'\n        // to something else, as this would lead to flickering when saving\n        // newly created content.\n        if (name === 'content-id' && oldVal !== newVal && oldVal !== 'new') {\n            await this.render(newVal);\n        }\n    }\n\n    /**\n     * Called when the component is added to the DOM.\n     */\n    public async connectedCallback(): Promise<void> {\n        this.appendChild(H5PEditorComponent.template.content.cloneNode(true));\n        this.root = this.querySelector('.h5p-editor-component-root');\n\n        this.resizeObserver = new ResizeObserver(() => {\n            this.resize();\n        });\n        this.resizeObserver.observe(this);\n\n        await this.render(this.contentId);\n    }\n\n    /**\n     * Called when the component is removed from the DOM.\n     */\n    public disconnectedCallback(): void {\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n            this.resizeObserver = null;\n        }\n\n        // Unregister our event listener from the global H5P dispatcher.\n        if (window.H5P?.externalDispatcher) {\n            window.H5P.externalDispatcher.off(\n                'editorloaded',\n                this.onEditorLoaded\n            );\n        }\n    }\n\n    /**\n     * Call this method when the iframe containing the editor needs to be\n     * resized, e.g. because the some\n     */\n    public resize = (): void => {\n        const h5pEditorIframe = this.querySelector(\n            '.h5p-editor-iframe'\n        ) as HTMLIFrameElement;\n        if (h5pEditorIframe) {\n            const newHeight =\n                h5pEditorIframe.contentWindow?.document?.body?.scrollHeight;\n            if (newHeight !== undefined) {\n                h5pEditorIframe.style.height = `${h5pEditorIframe.contentWindow.document.body.scrollHeight.toString()}px`;\n            }\n        }\n    };\n\n    /**\n     * Call save() to get data from the H5P editor and send it to the server.\n     * You can use the saveContentCallback hook to customize server requests.\n     * The component emits 'saved', 'save-error' and 'validation-error' events,\n     * depending on success of the function. You can subscribe to those or use\n     * the promise's return value and catch the errors in a try-catch block.\n     * @throws an error if something went wrong\n     * @returns the contentId and metadata of the saved content\n     */\n    public save = async (): Promise<{\n        contentId: string;\n        metadata: IContentMetadata;\n    }> => {\n        if (this.editorInstance === undefined) {\n            this.dispatchAndThrowError(\n                'save-error',\n                'editorInstance of h5p editor not defined.'\n            );\n        }\n        if (!this.saveContentCallback) {\n            this.dispatchAndThrowError(\n                'save-error',\n                'saveContentCallback of H5P Editor Web Component not defined.'\n            );\n        }\n\n        // Get parameters (and also validates them as a side effect)\n        const params = this.editorInstance.getParams();\n        if (!params.params) {\n            this.dispatchAndThrowError(\n                'validation-error',\n                'The parameters entered by the user are invalid.'\n            );\n        }\n        // Validate mandatory main title. Prevent submitting if that's not set.\n        // Deliberately doing it after getParams(), so that any other validation\n        // problems are also revealed.\n        if (!this.editorInstance.isMainTitleSet()) {\n            this.dispatchAndThrowError(\n                'validation-error',\n                \"The main title of the content hasn't been set.\"\n            );\n        }\n\n        let content: { library: string; params: string };\n        try {\n            content = await new Promise<{ library: string; params: string }>(\n                (res, rej) => {\n                    // By calling getContent we also upgrade the content (this\n                    // is an unexpected side effect)\n                    this.editorInstance.getContent(\n                        (c) => {\n                            res(c);\n                        },\n                        (err) => {\n                            rej(err);\n                        }\n                    );\n                }\n            );\n        } catch (error) {\n            this.dispatchAndThrowError('validation-error', error.toString());\n        }\n\n        let saveResponseObject: {\n            contentId: string;\n            metadata: IContentMetadata;\n        };\n\n        const requestBody = {\n            library: content.library,\n            params: JSON.parse(content.params)\n        };\n        try {\n            saveResponseObject = await this.saveContentCallback(\n                this.contentId === 'new' ? undefined : this.contentId,\n                requestBody\n            );\n        } catch (error) {\n            this.dispatchAndThrowError('save-error', error.message);\n        }\n\n        if (this.contentId !== saveResponseObject.contentId) {\n            this.setAttribute('content-id', saveResponseObject.contentId);\n        }\n\n        this.dispatchEvent(\n            new CustomEvent('saved', {\n                detail: {\n                    contentId: saveResponseObject.contentId,\n                    metadata: saveResponseObject.metadata\n                }\n            })\n        );\n        return saveResponseObject;\n    };\n\n    /**\n     * Dispatches an event of the specified name and throws an error whose error\n     * message starts with the eventName.\n     * @param eventName\n     * @param message\n     */\n    private dispatchAndThrowError(eventName: string, message: string): void {\n        this.dispatchEvent(\n            new CustomEvent(eventName, {\n                detail: {\n                    message\n                }\n            })\n        );\n        throw new Error(`${eventName}: ${message}`);\n    }\n\n    /**\n     * Called by the global H5P event dispatcher when any editor was loaded.\n     */\n    private onEditorLoaded = (event: { data: string }): void => {\n        // We must manually check if our editor instance is initialized, as the\n        // event is only sent globally.\n        if (this.editorInstance.selector.form) {\n            this.dispatchEvent(\n                new CustomEvent('editorloaded', {\n                    detail: { contentId: this.contentId, ubername: event.data }\n                })\n            );\n            // After our editor has been initialized, it will never fire the\n            // global event again, so we can unsubscribe from it.\n            if (window.H5P?.externalDispatcher) {\n                window.H5P.externalDispatcher.off(\n                    'editorloaded',\n                    this.onEditorLoaded\n                );\n            }\n        }\n    };\n\n    /**\n     * Displays the editor inside the component by creating a new DOM tree.\n     * @param contentId the content id to display or undefined if a new piece\n     * of content was created\n     */\n    private async render(contentId?: string): Promise<void> {\n        if (!this.loadContentCallback) {\n            return;\n        }\n\n        if (!contentId) {\n            return;\n        }\n\n        let editorModel: IEditorModel & {\n            library?: string;\n            metadata?: IContentMetadata;\n            params?: any;\n        };\n        try {\n            editorModel = await this.loadContentCallback(\n                contentId === 'new' ? undefined : contentId\n            );\n        } catch (error) {\n            this.root.innerHTML = `<p>Error loading H5P content from server: ${error.message}`;\n            return;\n        }\n\n        // Reset DOM tree inside component.\n        this.root.innerHTML = '';\n\n        // We have to prevent H5P from initializing when the h5p.js file is\n        // loaded.\n        if (!window.H5P) {\n            window.H5P = {} as any;\n        }\n        window.H5P.preventInit = true;\n\n        // We merge the H5P integration we received from the server with the one\n        // that already exists in the window globally to allow for several H5P\n        // content objects on a single page.\n        mergeH5PIntegration(\n            editorModel.integration,\n            contentId === 'new' ? undefined : contentId\n        );\n\n        // As the editor adds an iframe anyway and styles don't really matter, we\n        // only add the global editor scripts to the whole page, but not the styles\n        // (to avoid side effects).\n        await addScripts(\n            editorModel.scripts,\n            document.getElementsByTagName('head')[0]\n        );\n\n        // Create the necessary DOM tree.\n        const h5pCreateDiv = document.createElement('div');\n        h5pCreateDiv.className = 'h5p-create';\n        h5pCreateDiv.hidden = true;\n        this.root.appendChild(h5pCreateDiv);\n        const h5pEditorDiv = document.createElement('div');\n        h5pEditorDiv.className = 'h5p-editor';\n        h5pCreateDiv.appendChild(h5pEditorDiv);\n\n        // Set up the H5P core editor.\n        H5PEditor.getAjaxUrl = (\n            action: string,\n            parameters: { [x: string]: any }\n        ): string => {\n            let url = editorModel.integration.editor.ajaxPath + action;\n\n            if (parameters !== undefined) {\n                for (const property in parameters) {\n                    if (\n                        Object.prototype.hasOwnProperty.call(\n                            parameters,\n                            property\n                        )\n                    ) {\n                        url = `${url}&${property}=${parameters[property]}`;\n                    }\n                }\n            }\n\n            url += window.location.search.replace(/\\\\?/g, '&');\n            return url;\n        };\n\n        window.H5P.preventInit = false;\n        // Only initialize H5P once to avoid resetting values.\n        if (!window.h5pIsInitialized) {\n            window.H5P.init(this.root);\n            window.h5pIsInitialized = true;\n        }\n\n        // Register our global editorloaded event handler.\n        if (window.H5P.externalDispatcher) {\n            window.H5P.externalDispatcher.on(\n                'editorloaded',\n                this.onEditorLoaded,\n                this\n            );\n        }\n\n        // Configure the H5P core editor.\n        H5PEditor.$ = window.H5P.jQuery;\n        H5PEditor.basePath = editorModel.integration.editor.libraryUrl;\n        H5PEditor.fileIcon = editorModel.integration.editor.fileIcon;\n        H5PEditor.ajaxPath = editorModel.integration.editor.ajaxPath;\n        H5PEditor.filesPath = editorModel.integration.editor.filesPath;\n        H5PEditor.apiVersion = editorModel.integration.editor.apiVersion;\n        H5PEditor.contentLanguage = editorModel.integration.editor.language;\n        H5PEditor.copyrightSemantics =\n            editorModel.integration.editor.copyrightSemantics;\n        H5PEditor.metadataSemantics =\n            editorModel.integration.editor.metadataSemantics;\n        H5PEditor.assets = editorModel.integration.editor.assets;\n        H5PEditor.baseUrl = '';\n        H5PEditor.contentId = contentId === 'new' ? undefined : contentId;\n        H5PEditor.enableContentHub =\n            editorModel.integration.editor.enableContentHub || false;\n\n        if (contentId === 'new') {\n            // Create an empty editor for new content\n            this.editorInstance = new ns.Editor(\n                undefined,\n                undefined,\n                h5pEditorDiv\n            );\n        } else {\n            // Load the editor with populated parameters for existing content\n            this.editorInstance = new ns.Editor(\n                editorModel.library,\n                JSON.stringify({\n                    metadata: editorModel.metadata,\n                    params: editorModel.params\n                }),\n                h5pEditorDiv\n            );\n        }\n\n        h5pCreateDiv.hidden = false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}