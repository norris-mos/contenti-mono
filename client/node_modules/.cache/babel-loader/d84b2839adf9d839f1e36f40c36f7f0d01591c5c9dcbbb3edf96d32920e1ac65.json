{"ast":null,"code":"import _regeneratorRuntime from \"/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-rest-example-client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-rest-example-client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-rest-example-client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport AwaitLock from 'await-lock';\nvar lock = new AwaitLock();\n/**\n * Adds JavaScript file references to the DOM of the target element. If the\n * script was already added to the target element, it is not added a second\n * time. Makes sure the scripts are loaded in the order of the list.\n * @param scripts a list URLS to JavaScript files\n * @param target the element to which the scripts should be added.\n * @returns ignore the return value\n */\nexport function addScripts(_x, _x2) {\n  return _addScripts.apply(this, arguments);\n}\n/**\n * Adds links to CSS files to the DOM of the target element. If a stylesheet was\n * already added to the target element, it is not added a second time.\n * @param styles a list of URLs to stylesheets to add\n * @param target the element to which the scripts should be added\n * @param addFontsToHead if true, @font-face rules found in the loaded\n * stylesheets will also be duplicated and added to the head of the document.\n * This is necessary to load fonts that should be displayed inside the shadow\n * DOM.\n */\nfunction _addScripts() {\n  _addScripts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(scripts, target) {\n    var existingScripts;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return lock.acquireAsync();\n        case 2:\n          _context.prev = 2;\n          existingScripts = Array.from(target.getElementsByTagName('script')).map(function (el) {\n            return el.dataset.h5pSrc;\n          });\n          _context.next = 6;\n          return Promise.all(scripts.map(function (scriptUrl) {\n            // Only add scripts once\n            if (existingScripts.some(function (existingSrc) {\n              return existingSrc === scriptUrl;\n            })) {\n              return Promise.resolve();\n            }\n            var scriptTag = document.createElement('script');\n            scriptTag.src = scriptUrl;\n            // We store the original src used by H5P as the protocol and\n            // hostname are part of the src attribute.\n            scriptTag.dataset.h5pSrc = scriptUrl;\n            scriptTag.async = false;\n            scriptTag.defer = true;\n            var promise = new Promise(function (res, rej) {\n              scriptTag.onload = function () {\n                res();\n              };\n              scriptTag.onerror = rej;\n            });\n            target.appendChild(scriptTag);\n            return promise;\n          }));\n        case 6:\n          _context.prev = 6;\n          lock.release();\n          return _context.finish(6);\n        case 9:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2,, 6, 9]]);\n  }));\n  return _addScripts.apply(this, arguments);\n}\nexport function addStylesheets(styles, target) {\n  var existingTargetStylesheets = Array.from(target.getElementsByTagName('link')).map(function (el) {\n    return el.dataset.h5pHref;\n  });\n  var _iterator = _createForOfIteratorHelper(styles),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var styleUrl = _step.value;\n      // Only add stylesheets once\n      if (existingTargetStylesheets.some(function (h5pHref) {\n        return h5pHref === styleUrl;\n      })) {\n        return \"continue\";\n      }\n      var stylesheet = document.createElement('link');\n      // We store the original href in the data-h5p-attribute as the browser\n      // internally adds the protocol and hostname to the href attribute.\n      stylesheet.dataset.h5pHref = styleUrl;\n      stylesheet.rel = 'stylesheet';\n      stylesheet.href = styleUrl;\n      stylesheet.type = 'text/css';\n      target.appendChild(stylesheet);\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}","map":{"version":3,"names":["AwaitLock","lock","addScripts","_x","_x2","_addScripts","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","scripts","target","existingScripts","wrap","_callee$","_context","prev","next","acquireAsync","Array","from","getElementsByTagName","map","el","dataset","h5pSrc","Promise","all","scriptUrl","some","existingSrc","resolve","scriptTag","document","createElement","src","async","defer","promise","res","rej","onload","onerror","appendChild","release","finish","stop","addStylesheets","styles","existingTargetStylesheets","h5pHref","_iterator","_createForOfIteratorHelper","_step","_loop","styleUrl","value","stylesheet","rel","href","type","s","n","done","_ret","err","e","f"],"sources":["/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-webcomponents/src/dom-utils.ts"],"sourcesContent":["import AwaitLock from 'await-lock';\n\nconst lock = new AwaitLock();\n\n/**\n * Adds JavaScript file references to the DOM of the target element. If the\n * script was already added to the target element, it is not added a second\n * time. Makes sure the scripts are loaded in the order of the list.\n * @param scripts a list URLS to JavaScript files\n * @param target the element to which the scripts should be added.\n * @returns ignore the return value\n */\nexport async function addScripts(\n    scripts: string[],\n    target: HTMLElement\n): Promise<any> {\n    // We need to lock this function to avoid it being started nearly\n    // simultaneously. This can happen if several instances of the web component\n    // are added to the DOM at the same time. This can lead to situations in\n    // which the second run finds scripts that were already added to the DOM,\n    // but aren't parsed by the browser. The addScripts promise the resolves at\n    // a time when not all scripts have been fully loaded. This means that the\n    // global H5P objects and functions are not available yet, even though they\n    // should be.\n    await lock.acquireAsync();\n    try {\n        const existingScripts = Array.from(\n            target.getElementsByTagName('script')\n        ).map((el) => el.dataset.h5pSrc);\n        await Promise.all(\n            scripts.map((scriptUrl) => {\n                // Only add scripts once\n                if (\n                    existingScripts.some(\n                        (existingSrc) => existingSrc === scriptUrl\n                    )\n                ) {\n                    return Promise.resolve();\n                }\n                const scriptTag = document.createElement('script');\n                scriptTag.src = scriptUrl;\n                // We store the original src used by H5P as the protocol and\n                // hostname are part of the src attribute.\n                scriptTag.dataset.h5pSrc = scriptUrl;\n                scriptTag.async = false;\n                scriptTag.defer = true;\n                const promise = new Promise<void>((res, rej) => {\n                    scriptTag.onload = (): void => {\n                        res();\n                    };\n                    scriptTag.onerror = rej;\n                });\n\n                target.appendChild(scriptTag);\n                return promise;\n            })\n        );\n    } finally {\n        lock.release();\n    }\n}\n\n/**\n * Adds links to CSS files to the DOM of the target element. If a stylesheet was\n * already added to the target element, it is not added a second time.\n * @param styles a list of URLs to stylesheets to add\n * @param target the element to which the scripts should be added\n * @param addFontsToHead if true, @font-face rules found in the loaded\n * stylesheets will also be duplicated and added to the head of the document.\n * This is necessary to load fonts that should be displayed inside the shadow\n * DOM.\n */\nexport function addStylesheets(styles: string[], target: HTMLElement): void {\n    const existingTargetStylesheets = Array.from(\n        target.getElementsByTagName('link')\n    ).map((el) => el.dataset.h5pHref);\n\n    for (const styleUrl of styles) {\n        // Only add stylesheets once\n        if (existingTargetStylesheets.some((h5pHref) => h5pHref === styleUrl)) {\n            continue;\n        }\n        const stylesheet = document.createElement('link');\n        // We store the original href in the data-h5p-attribute as the browser\n        // internally adds the protocol and hostname to the href attribute.\n        stylesheet.dataset.h5pHref = styleUrl;\n        stylesheet.rel = 'stylesheet';\n        stylesheet.href = styleUrl;\n        stylesheet.type = 'text/css';\n        target.appendChild(stylesheet);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}