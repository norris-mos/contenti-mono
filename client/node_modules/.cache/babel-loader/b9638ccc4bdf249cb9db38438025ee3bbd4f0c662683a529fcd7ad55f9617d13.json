{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-rest-example-client/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-rest-example-client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-rest-example-client/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _AwaitLock_acquired, _AwaitLock_waitingResolvers;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * A mutex lock for coordination across async functions\n */\nvar AwaitLock = /*#__PURE__*/function () {\n  function AwaitLock() {\n    _classCallCheck(this, AwaitLock);\n    _AwaitLock_acquired.set(this, false);\n    _AwaitLock_waitingResolvers.set(this, new Set());\n  }\n  /**\n   * Whether the lock is currently acquired or not. Accessing this property does not affect the\n   * status of the lock.\n   */\n  _createClass(AwaitLock, [{\n    key: \"acquired\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _AwaitLock_acquired, \"f\");\n    }\n    /**\n     * Acquires the lock, waiting if necessary for it to become free if it is already locked. The\n     * returned promise is fulfilled once the lock is acquired.\n     *\n     * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before\n     * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid\n     * timeout values depends on how `setTimeout` handles those values.\n     *\n     * After acquiring the lock, you **must** call `release` when you are done with it.\n     */\n  }, {\n    key: \"acquireAsync\",\n    value: function acquireAsync() {\n      var _this = this;\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        timeout = _ref.timeout;\n      if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n        __classPrivateFieldSet(this, _AwaitLock_acquired, true, \"f\");\n        return Promise.resolve();\n      }\n      if (timeout == null) {\n        return new Promise(function (resolve) {\n          __classPrivateFieldGet(_this, _AwaitLock_waitingResolvers, \"f\").add(resolve);\n        });\n      }\n      var resolver;\n      var timer;\n      return Promise.race([new Promise(function (resolve) {\n        resolver = function resolver() {\n          clearTimeout(timer);\n          resolve();\n        };\n        __classPrivateFieldGet(_this, _AwaitLock_waitingResolvers, \"f\").add(resolver);\n      }), new Promise(function (_, reject) {\n        timer = setTimeout(function () {\n          __classPrivateFieldGet(_this, _AwaitLock_waitingResolvers, \"f\").delete(resolver);\n          reject(new Error(\"Timed out waiting for lock\"));\n        }, timeout);\n      })]);\n    }\n    /**\n     * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns\n     * `true` if the lock was free and is now acquired, and `false` otherwise.\n     *\n     * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs\n     * synchronously without waiting for the JavaScript task queue.\n     */\n  }, {\n    key: \"tryAcquire\",\n    value: function tryAcquire() {\n      if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n        __classPrivateFieldSet(this, _AwaitLock_acquired, true, \"f\");\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer\n     * must release the lock exactly once.\n     */\n  }, {\n    key: \"release\",\n    value: function release() {\n      if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n        throw new Error(\"Cannot release an unacquired lock\");\n      }\n      if (__classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").size > 0) {\n        // Sets preserve insertion order like a queue\n        var _classPrivateFieldGe = __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\"),\n          _classPrivateFieldGe2 = _slicedToArray(_classPrivateFieldGe, 1),\n          resolve = _classPrivateFieldGe2[0];\n        __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").delete(resolve);\n        resolve();\n      } else {\n        __classPrivateFieldSet(this, _AwaitLock_acquired, false, \"f\");\n      }\n    }\n  }]);\n  return AwaitLock;\n}();\nexports.default = AwaitLock;\n_AwaitLock_acquired = new WeakMap(), _AwaitLock_waitingResolvers = new WeakMap();","map":{"version":3,"names":["AwaitLock","_classCallCheck","_AwaitLock_acquired","set","_AwaitLock_waitingResolvers","Set","_createClass","key","get","__classPrivateFieldGet","value","acquireAsync","_this","_ref","arguments","length","undefined","timeout","__classPrivateFieldSet","Promise","resolve","add","resolver","timer","race","clearTimeout","_","reject","setTimeout","delete","Error","tryAcquire","release","size","_classPrivateFieldGe","_classPrivateFieldGe2","_slicedToArray","exports","default"],"sources":["/Users/maxoliverstapyltonnorris/H5P-Nodejs-library/packages/h5p-webcomponents/node_modules/await-lock/src/AwaitLock.ts"],"sourcesContent":["/**\n * A mutex lock for coordination across async functions\n */\nexport default class AwaitLock {\n  #acquired: boolean = false;\n  #waitingResolvers: Set<() => void> = new Set();\n\n  /**\n   * Whether the lock is currently acquired or not. Accessing this property does not affect the\n   * status of the lock.\n   */\n  get acquired(): boolean {\n    return this.#acquired;\n  }\n\n  /**\n   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The\n   * returned promise is fulfilled once the lock is acquired.\n   *\n   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before\n   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid\n   * timeout values depends on how `setTimeout` handles those values.\n   *\n   * After acquiring the lock, you **must** call `release` when you are done with it.\n   */\n  acquireAsync({ timeout }: { timeout?: number } = {}): Promise<void> {\n    if (!this.#acquired) {\n      this.#acquired = true;\n      return Promise.resolve();\n    }\n\n    if (timeout == null) {\n      return new Promise((resolve) => {\n        this.#waitingResolvers.add(resolve);\n      });\n    }\n\n    let resolver: () => void;\n    let timer: ReturnType<typeof setTimeout>;\n\n    return Promise.race<void>([\n      new Promise((resolve) => {\n        resolver = () => {\n          clearTimeout(timer);\n          resolve();\n        };\n        this.#waitingResolvers.add(resolver);\n      }),\n      new Promise<void>((_, reject) => {\n        timer = setTimeout(() => {\n          this.#waitingResolvers.delete(resolver);\n          reject(new Error(`Timed out waiting for lock`));\n        }, timeout);\n      }),\n    ]);\n  }\n\n  /**\n   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns\n   * `true` if the lock was free and is now acquired, and `false` otherwise.\n   *\n   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs\n   * synchronously without waiting for the JavaScript task queue.\n   */\n  tryAcquire(): boolean {\n    if (!this.#acquired) {\n      this.#acquired = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer\n   * must release the lock exactly once.\n   */\n  release(): void {\n    if (!this.#acquired) {\n      throw new Error(`Cannot release an unacquired lock`);\n    }\n\n    if (this.#waitingResolvers.size > 0) {\n      // Sets preserve insertion order like a queue\n      const [resolve] = this.#waitingResolvers;\n      this.#waitingResolvers.delete(resolve);\n      resolve();\n    } else {\n      this.#acquired = false;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}